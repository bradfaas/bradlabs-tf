version: 0.2
env:
  shell: bash
phases:
  install:
    commands:
      - curl -fsSL https://releases.hashicorp.com/terraform/1.9.5/terraform_1.9.5_linux_amd64.zip -o tf.zip
      - unzip -q tf.zip && mv terraform /usr/local/bin/ && terraform -version
  
  pre_build:
    commands:
      - set -e
      - if [ -z "${WINDOWS_APPS_JSON:-}" ]; then WINDOWS_APPS_JSON='[]'; fi
      - if [ -z "${LINUX_APPS_JSON:-}" ]; then LINUX_APPS_JSON='[]'; fi
      - if [ -z "${TAGS_JSON:-}" ]; then TAGS_JSON='{"project":"hands-on-lab"}'; fi
      - echo "Writing lab.auto.tfvars.json"
      - |
        python3 - <<'PY'
        import os, json, sys
        def jload(env, default_json):
            try:
                return json.loads(os.environ.get(env, default_json))
            except Exception as e:
                sys.stderr.write(f"Invalid JSON in ${env}: {e}\n"); sys.exit(2)
        out = {
            "region": os.environ["STATE_REGION"],
            "lab_id": os.environ["LAB_ID"],
            "user_id": os.environ["USER_ID"],
            "s3_app_bucket": os.environ["APP_BUCKET"],
            "domain_admin_password": os.environ["DOMAIN_ADMIN_PASSWORD"],
            "linux_user_password": os.environ.get("LINUX_DESKTOP_PASSWORD",""),
            "windows_admin_password": os.environ.get("WINDOWS_ADMIN_PASSWORD") or None,
            "create_domain_user": (os.environ.get("CREATE_DOMAIN_USER","true").lower() == "true"),
            "domain_user_password": os.environ.get("DOMAIN_USER_PASSWORD"),
            "windows_apps": jload("WINDOWS_APPS_JSON","[]"),
            "linux_apps": jload("LINUX_APPS_JSON","[]"),
            "tags": jload("TAGS_JSON",'{"project":"hands-on-lab"}')
        }
        with open("lab.auto.tfvars.json","w") as f: json.dump(out, f)
        PY
      
      - export TF_STATE_KEY="labs/${LAB_ID}.tfstate"
      - 'echo "State: s3://${STATE_BUCKET}/${TF_STATE_KEY}"'

  build:
    commands:
      - |
        # Portable safety flags (don’t break if pipefail is unsupported)
        - set -e
        - set -u
        - set -o pipefail 2>/dev/null || true
        echo "[Build] DESTROY=${DESTROY:-false}"

        # Always init the backend first
        echo "[Build] terraform init"
        terraform init \
          -backend-config="bucket=${STATE_BUCKET}" \
          -backend-config="key=${TF_STATE_KEY}" \
          -backend-config="region=${STATE_REGION}"

        if [[ "${DESTROY:-false}" == "true" ]]; then
          echo "[Build] DESTROY=true -> terraform destroy"
          terraform destroy -auto-approve
          echo '{}' > tf-outputs.json
        else
          echo "[Build] Applying lab infrastructure"
          terraform apply -auto-approve
          terraform output -json > tf-outputs.json || echo '{}' > tf-outputs.json

          # --- Orchestrate SSM in the correct order ---
          read_json() { jq -r "$1" tf-outputs.json; }
          
          DC_ID=$(read_json '.instance_ids.value.dc')
          WIN_ID=$(read_json '.instance_ids.value.win')
          LINUX_ID=$(read_json '.instance_ids.value.linux')
          
          DOC_SETUP=$(read_json '.doc_names.value.setup_dc')
          DOC_USER=$(read_json '.doc_names.value.create_ad_user')
          DOC_JOIN_WIN=$(read_json '.doc_names.value.join_domain_win')
          DOC_JOIN_LIN=$(read_json '.doc_names.value.join_domain_linux')
          
          DOMAIN="${DOMAIN_NAME:-lab.local}"
          NETBIOS="${NETBIOS_NAME:-LAB}"
          ADMIN_PW="${DOMAIN_ADMIN_PASSWORD}"
          USER_ID="${USER_ID}"
          USER_PW="${DOMAIN_USER_PASSWORD}"
          
          wait_online() {
            local iid="$1"
            for i in $(seq 1 180); do
              local ping
              ping=$(aws ssm describe-instance-information \
                        --filters "Key=InstanceIds,Values=${iid}" \
                        --query 'InstanceInformationList[0].PingStatus' \
                        --output text 2>/dev/null || true)
              if [[ "$ping" == "Online" ]]; then
                return 0
              fi
              sleep 10
            done
            echo "Instance $iid did not come Online in time"; return 1
          }
          
          build_params_json() {
            local json="{"
            local first=1
            for kv in "$@"; do
              local k="${kv%%=*}"
              local v="${kv#*=}"
              v="${v//\\/\\\\}"; v="${v//\"/\\\"}"
              if [[ $first -eq 1 ]]; then first=0; else json+=", "; fi
              json+="\"$k\":[\"$v\"]"
            done
            json+="}"
            printf '%s' "$json"
          }
          
          send_and_wait() {
            local doc="$1"; shift
            local iid="$1"; shift
            local params_json; params_json=$(build_params_json "$@")
          
            local CMD_ID
            if ! CMD_ID=$(aws ssm send-command \
                  --document-name "$doc" \
                  --targets Key=instanceids,Values="$iid" \
                  --parameters "$params_json" \
                  --query 'Command.CommandId' --output text); then
              echo "send-command failed for $doc on $iid"; return 1
            fi
            if [[ -z "$CMD_ID" || "$CMD_ID" == "None" || "$CMD_ID" == "null" ]]; then
              echo "send-command did not return a CommandId for $doc on $iid"; return 1
            fi
            echo "Command $doc -> $iid : $CMD_ID"
          
            for i in $(seq 1 180); do
              local STATUS
              STATUS=$(aws ssm get-command-invocation \
                         --command-id "$CMD_ID" \
                         --instance-id "$iid" \
                         --query 'Status' --output text 2>/dev/null || true)
              case "$STATUS" in
                Success) return 0 ;;
                Failed|Cancelled|TimedOut)
                  aws ssm get-command-invocation \
                    --command-id "$CMD_ID" --instance-id "$iid" \
                    --query '{StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
                    --output json || true
                  echo "Command $doc failed with status $STATUS"
                  return 1 ;;
              esac
              sleep 10
            done
            echo "Command $doc did not complete in time"; return 1
          }
          
          # wait for SSM Online BEFORE promoting the DC
          echo "Wait for DC SSM Online before promotion…"
          wait_online "$DC_ID" || exit 1
          
          echo "1) Promote DC"
          send_and_wait "$DOC_SETUP" "$DC_ID" "AdminPassword=$ADMIN_PW" || exit 1
          
          echo "Wait for DC reboot and SSM Online…"
          sleep 30
          wait_online "$DC_ID" || exit 1
          
          echo "2) Create/enable domain user"
          send_and_wait "$DOC_USER" "$DC_ID" "UserId=$USER_ID" "UserPassword=$USER_PW" || exit 1
          
          echo "3) Join Windows desktop (will reboot)"
          DCIP=$(aws ec2 describe-instances --instance-ids "$DC_ID" \
                  --query 'Reservations[0].Instances[0].PrivateIpAddress' --output text)
          send_and_wait "$DOC_JOIN_WIN" "$WIN_ID" "DcIp=$DCIP" "AdminPassword=$ADMIN_PW" || exit 1
          echo "Wait for Windows reboot and Online…"
          sleep 30
          wait_online "$WIN_ID" || exit 1
          
          echo "4) Join Linux desktop"
          send_and_wait "$DOC_JOIN_LIN" "$LINUX_ID" "DcIp=$DCIP" "DomainName=$DOMAIN" "Netbios=$NETBIOS" "AdminPassword=$ADMIN_PW" || exit 1
          
          echo "SSM orchestration complete."

        fi
        
      - 'echo "[Build] Final artifact contents:"'
      - ls -la tf-outputs.json




artifacts:
  files:
    - tf-outputs.json
